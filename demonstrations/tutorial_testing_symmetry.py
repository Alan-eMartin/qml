r"""
Testing for symmetry with quantum computers
-------------------------------------------

.. meta::
    :property="og:description": Test if a system possesses discrete symmetries
    :property="og:image": demonstrations/testing_symmetry/thumbnail.png

*Author: David Wakeham. Posted: 25 November 2021. Last updated: 25 November 2021.*

Introduction
----------------

Symmetries are transformations that leave something looking the same.
They are all-important in quantum mechanics, encoding crucial
information about both the static and dynamic properties of systems, for
instance, numbers that are conserved or the form our Hilbert space can
take. Symmetries need not be exact, since a system can look
approximately, rather than exactly, the same after a transformation. It
therefore makes sense to have an algorithm to determine if a Hamiltonian
has an approximate symmetry.

.. figure:: ../demonstrations/testing_symmetry/symm2.png
   :alt: symm
   :align: center
   :width: 40%

In this demo, we’ll implement the elegant algorithm of `LaBorde and
Wilde (2022) <https://arxiv.org/pdf/2203.10017.pdf>`__ for testing the
symmetries of a Hamiltonian. We’ll be able to determine whether a system
has a finite group of symmetries :math:`G`, and if not, by how much the
symmetry is violated.

Background
--------------

We will encode symmetries into a `finite group
<https://en.wikipedia.org/wiki/Finite_group>`__. This is an
algebraic structure consisting of transformations :math:`g`, which act
on the Hilbert space :math:`\mathcal{H}` of our system in the form of
unitary operators :math:`U(g)` for :math:`g \in G`. Informally, the
transformations :math:`g\in G` can be multiplied,
:math:`g \cdot g' \in G`, and are subject to three constraints: (a)
transformations compose, so multiplication is associative; (b) there is
a boring transformation :math:`e` that does nothing; and (c) every
transformation :math:`g` can be done in reverse, as :math:`g^{-1}`. In
math:

.. math::
   \begin{align*}
   (g \cdot g'') \cdot g''' & = g \cdot (g'' \cdot g''') \\
   g \cdot e & = e \cdot g = e  \\
   g \cdot g^{-1} & = g^{-1} \cdot g = e.
   \end{align*}

Since transformations compose, the unitary operators must satisfy

.. math::


   U(g)U(g') = U(g \circ g').

Technically, they form a *representation* of the group :math:`G`. For
the Hamiltonian to respect the symmetry means that it commutes with all
the matrices,

.. math::


   [U(g),\hat{H}] = 0.

Since the Hamiltonian generates time evolution, this means that if we
apply a group transformation now or we apply it later, the effect is the
same. Thus, we seek an algorithm which checks if these commutators are
zero.

Averaging over symmetries
-----------------------------

To verify that the Hamiltonian is symmetric with respect to :math:`G`, it
seems like we will need to check each element
:math:`g \in G` separately. There is a clever way to avoid this and boil
it all down to a single number. For now, we’ll content ourselves with
looking at the *average* over the group:

.. math:: \frac{1}{|G|}\sum_{g\in G}[U(g),\hat{H}] = 0. 

To make things concrete, let’s consider a group
:math:`G = \mathbb{Z}_4`, rotations of the square. If we place a qubit
on each corner, this group will naturally act on four qubits.

.. figure:: ../demonstrations/testing_symmetry/square.png
   :alt: square
   :align: center
   :width: 30%

It is generated by a single rotation, which we’ll call :math:`c`. We’ll
consider three Hamiltonians: one which is exactly symmetric with respect
to :math:`G` (called :math:`\hat{H}_1`), one which is almost symmetric
(called :math:`\hat{H}_2`), and one which isn’t at all symmetric
(called :math:`\hat{H}_3`). We'll define them by

.. math:: \begin{align*}
   \hat{H}_1 & = X_0 + X_1 + X_2 + X_3\\
   \hat{H}_2 & = X_0 + 1.1 \cdot X_1 + 0.9 \cdot X_2 + X_3 \\
   \hat{H}_3 & = X_0 + 2\cdot X_1 + 3\cdot X_2.
   \end{align*}

Let’s see how this looks in PennyLane. We’ll create a register
``system`` with four wires, one for each qubit. The generator :math:`c`
acts as a permutation:

.. math:: \vert x_0 x_1 x_2 x_3\rangle \overset{c}{\mapsto} \vert x_3 x_0 x_1 x_2\rangle.

The simplest way to do this is using
:class:`Permute <pennylane.Permute>`.
We can convert this into a matrix using
:class:`matrix <pennylane.matrix>`.
We can obtain any other element :math:`g\in G` by simply iterating
:math:`c` the appropriate number of times.

"""

import pennylane as qml
from pennylane import numpy as np

# Create wires for the system
system = range(4)

# The generator of the group
c = qml.templates.Permute([3, 0, 1, 2], wires=system)
c_mat = qml.matrix(c)


######################################################################
# To create the Hamiltonians, we use
# :class:`Hamiltonian <pennylane.Hamiltonian>`:
#

# Create Hamiltonians
obs = [qml.PauliX(system[0]), qml.PauliX(system[1]), qml.PauliX(system[2]), qml.PauliX(system[3])]
coeffs1, coeffs2, coeffs3 = [1, 1, 1, 1], [1, 1.1, 0.9, 1], [1, 2, 3, 0]
H1, H2, H3 = (
    qml.Hamiltonian(coeffs1, obs),
    qml.Hamiltonian(coeffs2, obs),
    qml.Hamiltonian(coeffs3, obs),
)


######################################################################
# To arrive at the algorithm for testing this average symmetry property,
# we start with a trick called the `Choi-Jamiołkowski
# isomorphism <https://en.wikipedia.org/wiki/Choi%E2%80%93Jamio%C5%82kowski_isomorphism>`__
# for thinking of time evolution as a state instead of an operator. It’s
# easy to describe in words: make a copy :math:`\mathcal{H}_\text{copy}`
# of the system :math:`\mathcal{H}`, create a maximally entangled state,
# and time evolve the state on :math:`\mathcal{H}`. In fact, this trick works to
# give a dual state :math:`\vert\Phi^U\rangle` for any operator :math:`U`, as below:
#
# .. figure:: ../demonstrations/testing_symmetry/choi.png
#    :alt: choi
#    :align: center
#    :width: 50%
#
# We've pictured entanglement by joining the wires corresponding to the system and the copy.
# For time evolution, we’ll call the dual state
# :math:`\vert\Phi_t\rangle`, and formally define it:
#
# .. math::
#
#
#    \vert\Phi_t\rangle = \frac{1}{\sqrt{d}}\sum_{i=1}^d e^{-it\hat{H}}\vert i\rangle \otimes \vert i_\text{copy}\rangle.
#
# You can show mathematically that the average symmetry condition is equivalent to
#
# .. math::
#
#
#    \Pi_G\vert\Phi_t\rangle = \vert\Phi_t\rangle,
#
# where :math:`\Pi_G` is an operator defined by
#
# .. math::
#
#
#    \Pi_G  = \frac{1}{|G|}\sum_{g\in G} U(g) \otimes \overline{U(g)}.
#
# A little algebra shows that :math:`\Pi_G^2 = \Pi_G`, and hence it is a
# *projector*, with an associated measurement, asking: is the state
# symmetric on average? This is a mathematical way of
# saying that the answer is “yes”. So, our goal now is write a circuit
# which (a) prepares the :math:`\vert\Phi_t\rangle`, and (b) performs the
# measurement :math:`\Pi_G`. Part (a) is simpler. In general, we can just
# use a “cascade” of Hadamards and CNOTs, similar to the usual circuit for
# generating a Bell state on two qubits, as pictured below:
#
# .. figure:: ../demonstrations/testing_symmetry/bells.png
#    :alt: bells
#    :align: center
#    :width: 50%
#
# Let’s implement this for our four-qubit system in PennyLane:
#

# Create copy of the system
copy = range(4, 8)

# Prepare entangled state on system and copy
def prep_entangle():
    for wire in copy:
        qml.Hadamard(wire)
        qml.CNOT(wires=[wire, wire - 4])


######################################################################
# We then need to implement time evolution on the system. In applications,
# the system’s evolution could be a “black box” we can query, or something
# given to us analytically. In general, we can approximate time evolution
# with
# :class:`ApproxTimeEvolution <pennylane.ApproxTimeEvolution>`.
# However, since our Hamiltonians consist of terms that *commute*, we will
# be able to evolve exactly using
# :class:`CommutingEvolution <pennylane.CommutingEvolution>`.
# This is it for part (a)!
#

# Create group register and device
aux = range(8, 10)
dev = qml.device("default.qubit", wires=10)

# Create plus state
def prep_plus():
    qml.Hadamard(wires=aux[0])
    qml.Hadamard(wires=aux[1])


######################################################################
# Controlled symmetries
# -------------------------
#
# Part (b) is more interesting. We could try rotating into a basis some
# times are symmetric and some states aren’t, but it turns out to be
# simpler just use an auxiliary register :math:`\mathcal{H}_G` which
# encodes :math:`G`, with basis elements :math:`\vert g\rangle` labelled
# by group elements :math:`g \in G`. This needs :math:`\log \vert G\vert`
# qubits, which (along with any Hamiltonian simulation) will form the main
# resource cost of the algorithm. These will then can group
# transformations to a state
# :math:`\vert\psi\rangle \in \mathcal{H}\otimes \mathcal{H}_\text{copy}`
# in a controlled way via
#
# .. math::
#
#
#    \vert{\psi}\rangle \otimes \vert g\rangle \mapsto (U(g)\otimes \overline{U(g)})\vert{\psi} \rangle \otimes \vert g\rangle_G,
#
# which we’ll call :math:`CU`. We take this controlled gate as a
# primitive. To test average symmetry, we simply place
# :math:`\mathcal{H}_G` in a uniform superposition
#
# .. math::
#
#
#    \vert +\rangle_G = \frac{1}{\sqrt{|G|}}\sum_{g\in G} \vert g\rangle_G
#
# and apply the controlled operator to the state generated in part (a).
# This gives
#
# .. math::
#
#
#    \vert\Phi_t\rangle \otimes \vert +\rangle_G \mapsto \frac{1}{\sqrt{|G|}}\sum_{g\in G}(U(g)\otimes \overline{U(g)})\vert\Phi_t\rangle \otimes \vert g\rangle_G.
#
# This isn’t quite what we want yet, in particular because the system
# :math:`\mathcal{H}` is entangled not only with the copy, but also with
# the register :math:`\mathcal{H}_G`. To fix this, we observe the
# *register*, and see if it’s in the superposition
# :math:`\vert+\rangle_G`. The state, conditioned on this observation, is
#
# .. math::
#
#
#    \begin{align*}
#    {}_G\langle +\vert \frac{1}{\sqrt{|G|}}\sum_{g\in G}(U(g)\otimes \overline{U(g)})\vert\Phi_t\rangle \otimes \vert g\rangle_G & = \frac{1}{|G|}\sum_{g, g'\in G}(U(g)\otimes \overline{U(g)})\vert\Phi_t\rangle \langle g'\vert g\rangle_G \\ & = \Pi_G \vert\Phi_t\rangle,
#    \end{align*}
#
# and hence the probability of observing it is
#
# .. math::
#
#
#    P_+ = \vert \Pi_G \vert\Phi_t\rangle \vert^2 = \langle \Phi_t \vert \Pi_G^\dagger \Pi_G\vert\Phi_t\rangle = \langle \Phi_t \vert \Pi_G\vert\Phi_t\rangle
#
# This is exactly what we want! So, let’s code all this up for our
# example. We’ll need two qubits for our auxiliary register
# :math:`\mathcal{H}_G`. To place it in a uniform superposition, just
# apply a Hadamard gate to each qubit. To measure the
# :math:`\vert+\rangle_G` state at the end, we undo these Hadamards and
# try to measure “:math:`00`”. Finally, it’s straightforward to implement
# the controlled gate :math:`CU` using controlled
# operations (namely :class:`ControlledQubitUnitary`<pennylane.ControlledQubitUnitary>)
# on each qubit:
#
# .. figure:: ../demonstrations/testing_symmetry/cu.png
#    :alt: cu
#    :align: center
#    :width: 50%
#

# Implement controlled symmetry operations on system
def CU_sys():
    qml.ControlledQubitUnitary(c_mat @ c_mat, control_wires=[aux[0]], wires=system)
    qml.ControlledQubitUnitary(c_mat, control_wires=[aux[1]], wires=system)


# Implement controlled symmetry operations on copy
def CU_cpy():
    qml.ControlledQubitUnitary(c_mat @ c_mat, control_wires=[aux[0]], wires=copy)
    qml.ControlledQubitUnitary(c_mat, control_wires=[aux[1]], wires=copy)

######################################################################
# Let’s combine everything and actually run our circuit! We can perform
# exact time evolution for our Hamiltonians, since the terms commute:
#

# Circuit for average symmetry
@qml.qnode(dev)
def avg_symm(ham, time):

    # Use Choi-Jamiołkowski isomorphism
    prep_entangle()
    qml.CommutingEvolution(ham, time)

    # Apply controlled symmetry operations
    prep_plus()
    CU_sys()
    CU_cpy()

    # Ready register for measurement
    prep_plus()

    return qml.probs(wires=aux)


print("For Hamiltonian H1, the |+> state is observed with probability", avg_symm(H1, 1)[0], ".")
print("For Hamiltonian H2, the |+> state is observed with probability", avg_symm(H2, 1)[0], ".")
print("For Hamiltonian H3, the |+> state is observed with probability", avg_symm(H3, 1)[0], ".")


######################################################################
# We see that for the symmetric Hamiltonian, we’re *certain* to observe
# :math:`\vert +\rangle_G`. We’re very likely to observe
# :math:`\vert +\rangle_G` for the near-symmetric Hamiltonian, and our
# chances suck for the asymmetric Hamiltonian.
#


######################################################################
# A short time limit
# ----------------------
#
# This circuit leaves a few things to be desired. First, it only measures
# whether our Hamiltonian is symmetric *on average*. What if we want to
# know if it’s symmetric full-stop? We could run the circuit for each
# element :math:`g\in G`, but perhaps there is a better way. Second, even
# if we could do that, we don’t know what the numbers coming out of the
# circuit mean.
# We can address both questions by considering very short times,
# :math:`t \to 0`. In this case, we can Taylor expand the unitary
# time-evolution operator,
#
# .. math::
#
#
#    e^{-it \hat{H}} = \mathbb{I} - it \hat{H} - \frac{t^2 \hat{H}^2}{2} + O(t^3).
#
# We’ll assume that, if we’re simulating the evolution, the expansion is
# accurate to this order. In this case, it’s possible to show (with a page
# or so of algebra the brave reader is invited to provide) that the
# probability :math:`P_+` of observing the :math:`\vert +\rangle_G` state
# is
#
# .. math::
#
#
#    P_+ = \langle \Phi_t \vert \Pi_G \vert \Phi_t\rangle = 1 - \frac{t^2}{2d \vert G\vert}\sum_{g\in G}\vert\vert [U(g), \hat{H}] \vert\vert_2^2 + O(t^3),
#
# where :math:`\vert\vert\cdot\vert\vert_2` represents the usual
# (Pythagorean) :math:`2`-norm. This is a sharp expression relating the
# output of the circuit :math:`P_+` to a quantity measuring of the degree
# of symmetry or lack therefore, the sum of squared commutator norms.
# We’ll call this sum the *asymmetry* :math:`\xi`. Rearranging, we have
#
# .. math::
#
#
#    \xi = \sum_{g\in G}\vert\vert [U(g), \hat{H}] \vert\vert_2^2 = \frac{2d\vert G\vert(1 - P_+)}{t^2} + O(t).
#
# Let’s see how this works in our example. Here, :math:`d` is the
# dimension of the system, so in our four-qubit case, :math:`d=2^4 = 16`,
# while :math:`\vert G\vert = 4`.
#

# Define asymmetry circuit
def asymm(ham, time):
    d, G = 16, 4
    P_plus = avg_symm(ham, time)[0]
    xi = 2 * d * (1 - P_plus) / (time ** 2)
    return xi


print("The asymmetry for H1 is", asymm(H1, 1e-4), ".")
print("The asymmetry for H2 is", asymm(H2, 1e-4), ".")
print("The asymmetry for H3 is", asymm(H3, 1e-4), ".")


######################################################################
# Our symmetric Hamiltonian :math:`\hat{H}_1` has a near-zero asymmetry as
# expected. (Note that making the time very small leads to a larger
# asymmetry because of numerical artifacts.) The near-symmetric
# Hamiltonian :math:`\hat{H}_2` has an asymmetry much larger than
# :math:`O(t)`, telling us that :math:`\xi` is a more easily understood
# measure of symmetry than :math:`P_+`. Finally, the Hamiltonian
# :math:`\hat{H}_3` has a huge error; it is not even approximately
# symmetric.
#


######################################################################
# Concluding remarks
# ----------------------
#
# Symmetries are physically important in quantum mechanics. Most systems
# of interest are large and complex, and even with an explicit description
# of a Hamiltonian, symmetries can be hard to determine by hand. Testing
# for symmetry when we have access to Hamiltonian evolution (either
# physically or by simulation) is thus a natural target for quantum
# computing.
#
# Here, we’ve described a simple algorithm to check if a system with
# Hamiltonian :math:`\hat{H}` is approximately symmetric with respect to a
# finite group :math:`G`. More precisely, for short times, applying
# controlled symmetry operations to the state dual to Hamiltonian
# evolution gives the asymmetry
#
# .. math::
#
#
#    \xi = \sum_{g\in G} \vert\vert [U(g), H]\vert\vert^2_2.
#
# This vanishes just in case the system possesses the symmetry, and
# otherwise tells us by how much it is violated. The main overhead is the
# size of the register encoding the group, which scales logarithmically
# with :math:`\vert G\vert`.
# So, it's expensive in memory for big groups, but quick to run!


######################################################################
# References
# --------------
#
# 1. LaBorde, M. L and Wilde, M.M. `Quantum Algorithms for Testing
#    Hamiltonian Symmetry <https://arxiv.org/pdf/2203.10017.pdf>`__
#    (2022).
#

##############################################################################
# About the author
# ----------------
# .. include:: ../_static/authors/david_wakeham.txt
