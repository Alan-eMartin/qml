r"""Intro to QROM
=============================================================

Storing and loading data is an indispensable task on any computer. Quantum computers are no different and getting this
done efficiently plays a crucial role in fields such as QML or can even be useful in search algorithms.
In this demo we will introduce the concept of QROM, the data structure that allows us to work towards this task.

QROM
-----

Quantum Read-Only Memory (QROM) is an operator that allows us to load classical data into a quantum computer
associated with indeces. This data is represented as a bitstring (list of 0s and 1s) and the operator can be defined as:

.. math::

    \text{QROM}|i\rangle|0\rangle = |i\rangle|b_i\rangle,

where :math:`|b_i\rangle` is the bitstring associated with the index :math:`i`.
Suppose our data consists of four bit-strings: :math:`[11, 01, 11, 00, 10, 10, 11, 00]`. Then, the index register will consist of three
qubits (:math:\`log_2 8`) and the target register of two qubits (length of the bit-strings). Following the same example:

.. math::

    \text{QROM}|010\rangle|000\rangle = |010\rangle|11\rangle,

since the bit-string associated with index :math:`2` is :math:`11`.
We will show three different implementations of this operator: Select, SelectSwap and an advanced version of the
last one.

Select
~~~~~~~

The Select operator has a more generic definition than QROM and serves as a first approach to
create it. It is defined as:

.. math::

    \text{Sel}|i\rangle|0\rangle = |i\rangle|\phi_i\rangle,

where :math:`|\phi_i\rangle` is the i-th state we want to encode generated by a known-gate :math:`U_i`.
Since the bitstrings can be seen as a particular quantum state, we particularize this operator to the QROM case.
For the following example we are going to use :class:`~.pennylane.BasisEmbedding` as :math:`U_i`, and
the :class:`~.pennylane.Select` template provided by PennyLane.

"""

import pennylane as qml
from functools import partial

control_wires = [0,1,2]
target_wires = [3,4]

bitstrings = ["11", "01", "11", "00", "10", "10", "11", "00"]
Ui = [qml.BasisEmbedding(int(bitstring, 2), target_wires) for bitstring in bitstrings]

dev = qml.device("default.qubit", shots = 1)


# I put this line so that the circuit can be visualized more clearly afterwards.
@partial(qml.devices.preprocess.decompose, stopping_condition = lambda obj: False, max_expansion=1)
@qml.qnode(dev)
def circuit(index):
    qml.BasisEmbedding(index, wires=control_wires)
    qml.Select(Ui, control=control_wires)
    return qml.sample(wires=target_wires)

for i in range(8):
    print(f"The bitstring stored in the {i}-index is: {circuit(i)}")

##############################################################################
# Nice, the bitstrings have been entered correctly.
# Let's draw the circuit to see how it's built:

qml.draw_mpl(circuit)(0)

##############################################################################
# Although the algorithm works correctly, we can see that the number of multicontrol gates is very high.
# Improving the efficiency of these circuits is of vital importance and current research area.
# A great technique to simplify this multicontrol gates can be found in this work [google], which makes use of mid-circuit
# measurements to minimize the number of CNOTs and T-gates needed.
#
# SelectSwap
# ~~~~~~~~~~
#
# Reusable SelectSwap
# ~~~~~~~~~~~~~~~~~~~
#
# Conclusion
# ----------
#
#
# About the author
# ----------------
# .. include:: ../_static/authors/juan_miguel_arrazola.txt
