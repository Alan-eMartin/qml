r"""Intro to QROM
=============================================================

Managing data is a crucial task on any computer, and quantum computers are no exception. Efficient data management is vital in quantum machine learning, search algorithms, and state preparation.
In this demonstration, we will introduce the concept of a Quantum Read-Only Memory (QROM), a data structure designed to load classical data on a quantum computer.

QROM
-----

The QROM is an operator that allows us to load classical data into a quantum computer. Data is represented as a collection of bitstrings (list of 0s and 1s) that we denote by :math:`b_1, b_2, \ldots, b_N`. The QROM operator is then defined as:

.. math::

    \text{QROM}|i\rangle|0\rangle = |i\rangle|b_i\rangle,

where :math:`|b_i\rangle` is the bitstring associated with the index :math:`i`.

For example, suppose our data consists of eight bit-strings, each with two bits: :math:`[11, 01, 11, 00, 10, 10, 11, 00]`. Then, the index register will consist of three
qubits (:math:`3 = \log_2 8`) and the target register of two qubits (length of the bit-strings). In this case, the QROM operator acts as 
:math:`\text{QROM}|010\rangle|00\rangle = |010\rangle|11\rangle`, since the bit-string associated with index :math:`2` is :math:`11`.

We will now explain three different implementations of a QROM: Select, SelectSwap, and an extension of SelectSwap.

Select
~~~~~~~

More generally, Select is an operator that prepares quantum states associated with indices. It is defined as:

.. math::

    \text{Sel}|i\rangle|0\rangle = |i\rangleU_i|0\rangle =|i\rangle|\phi_i\rangle,

where :math:`|\phi_i\rangle` is the i-th state we want to encode generated by a known-gate :math:`U_i`.
Since the bitstrings are encoded in computational basis states, we can view QROM as a special case of a Select operator.
For the following example we are going to use :class:`~.pennylane.BasisEmbedding` as :math:`U_i`, and
the :class:`~.pennylane.Select` template provided by PennyLane.

"""

import pennylane as qml
from functools import partial

control_wires = [0,1,2]
target_wires = [3,4]

bitstrings = ["01", "11", "11", "00", "01", "11", "11", "00"]
Ui = [qml.BasisEmbedding(int(bitstring, 2), target_wires) for bitstring in bitstrings]

dev = qml.device("default.qubit", shots = 1)

# This line is included for drawing purposes only.
@partial(qml.devices.preprocess.decompose,
         stopping_condition = lambda obj: False,
         max_expansion=1)

@qml.qnode(dev)
def circuit(index):
    qml.BasisEmbedding(index, wires=control_wires)
    qml.Select(Ui, control=control_wires)
    return qml.sample(wires=target_wires)

##############################################################################
# Once we have defined the circuit, we can draw it and check that the outputs are as expected.

import matplotlib.pyplot as plt

qml.draw_mpl(circuit, style = "pennylane")(0)
plt.show()

for i in range(8):
    print(f"The bitstring stored in index{i} is: {circuit(i)}")


##############################################################################
# Nice, you can see that the outputs match the elements of our initial data list.
#
# Although the algorithm works correctly, the number of multicontrol gates is high.
# The decomposition of these gates is expensive and there are numerous works that attempt to simplify this.
# We highlight the work [#unary]_ which introduces an efficient technique using measurements in the middle
# of the circuit. Another clever approach was introduced in [#selectSwap]_ , with a smart structure known as SelectSwap, which we describe below.
#
# SelectSwap
# ~~~~~~~~~~
# The goal of the SelectSwap construction is to trade depth for width. That is, using multiple auxiliary qubits,
# we reduce the circuit depth required to build the QROM. We can detail the algorithm in two steps.
#
# .. figure:: ../_static/demonstration_assets/qrom/select_swap.jpeg
#    :align: center
#    :width: 70%
#    :target: javascript:void(0)
#
# First, we use the auxiliary qubits to store more than one bitstring per column.
# In this way, we reduce the number of operators that Select requires. The main idea is to organize the data in two dimensions, with each bitstring labelled by a column index and a row index. 
# The control qubits of the Select block determine the column index, while a
# swap block is used to detect the row index and swap the data to the
# the target wires.
#
# Note that with more auxiliary qubits we could make larger groupings of bitstrings reducing the workload of the
# Select operator. Below we show an example with two columns and four rows:
#
# .. figure:: ../_static/demonstration_assets/qrom/select_swap_4.jpeg
#    :align: center
#    :width: 70%
#    :target: javascript:void(0)
#
# Reusable qubits
# ~~~~~~~~~~~~~~~~~
#
# The above approach has a drawback. The work wires have been altered, i.e., after applying the operator they have not
# been returned to state :math:`|0\rangle`. This can cause unwanted behaviors, so we will present the technique shown
# in [#cleanQROM]_ to solve this.
#
# .. figure:: ../_static/demonstration_assets/qrom/clean_version_2.jpeg
#    :align: center
#    :width: 90%
#    :target: javascript:void(0)
#
# Following the same idea as before, the control wires of the select block will choose the column :math:`c` where the
# bitstring is located, and the control wires of the swap block determine the row :math:`r`.
# We can summarize the idea of why the circuit works in a few simple steps:
#
# 1. **We start by generating the uniform superposition on the r-th register**.
#
# .. math::
#       |c\rangle |r\rangle |0\rangle \dots |+\rangle_r \dots |0\rangle
#
# 2. **We apply the Select block.** We denote by :math:`b_{cr}` the bitstring of column :math:`c` and row :math:`r`. Note that in the :math:`r`-th position, the Select has no effect since this state is not modified by :math:`X` gates.
#
# .. math::
#       |c\rangle |r\rangle |b_{c0}\rangle \dots |+\rangle_r \dots |b_{cR}\rangle
#
#
# 3. **We apply the Hadamard's in r-th register.**
#
# .. math::
#       |c\rangle |r\rangle |b_{c0}\rangle \dots |0\rangle_r \dots |b_{cR}\rangle
#
# 4. **We apply Select again to the state.** Note that applying Select twice on a state is equivalent to the identity.
#
# .. math::
#       |c\rangle |r\rangle |0\rangle \dots |b_{cr}\rangle_r \dots |0\rangle
#
# That's it! With a last swap we have managed to load the bitstring of column :math:`c` and row :math:`r` in the target wires.
#
# QROM in PennyLane
# -----------------
# Coding a QROM circuit from scratch can be painful, but with the help of PennyLane you can do it in just one line.
# We are going to encode the same bitstrings, using the SelectSwap approach. In this example we use two work wires
# to store two blocks per column and we will show an example with a superposition input:

import numpy as np

control_wires = [0,1,2]
target_wires = [3,4]
work_wires = [5,6]

# This function is included for drawing purposes only.
def my_stop(obj):
  if obj.name in ["CSWAP", "PauliX", "Hadamard"]:
    return True
  return False

@partial(qml.devices.preprocess.decompose, stopping_condition = my_stop, max_expansion=2)
@qml.qnode(qml.device("default.qubit"))
def circuit():

  qml.PauliX(control_wires[-3])
  qml.Hadamard(control_wires[-1])
  qml.Hadamard(control_wires[-2])

  qml.QROM(bitstrings, control_wires, target_wires, work_wires, clean = False)

  return qml.probs(wires = target_wires)

qml.draw_mpl(circuit, style = "pennylane")()
plt.show()

print("Probability of getting |11‚ü©: ", np.round(circuit()[-1],2))

##############################################################################
# In this case we are using as input in the control wires the state:
#
# .. math::
#
#   |\phi\rangle = \frac{|100\rangle + |101\rangle + |110\rangle + |111\rangle}{2}.
#
# The bitstrings associated with each of these are :math:`01`, :math:`11`, :math:`11` and :math:`00` respectively.
# Therefore, as we got, the probability of measuring :math:`|11\rangle` in the target wires is :math:`\frac{2}{4}`.
#
# If we want to use the approach that cleans the work wires, we could set the ``clean`` attribute of QROM to ``True``.
# Let's see how the circuit looks like:

@partial(qml.devices.preprocess.decompose, stopping_condition = my_stop, max_expansion=2)
@qml.qnode(qml.device("default.qubit"))
def circuit():

  qml.QROM(bitstrings, control_wires, target_wires, work_wires, clean = True)

  return qml.sample(wires = target_wires)

qml.draw_mpl(circuit, style = "pennylane")()
plt.show()

##############################################################################
# Beautiful! The circuit is more complex, but the work wires are clean.
# As a curiosity, this template works with work wires that are not initialized to zero.
#
#
#
# Conclusion
# ----------
#
# By implementing various versions of the QROM operator, such as Select and SelectSwap, we optimize quantum circuits
# for enhanced performance and scalability. Numerous studies demonstrate the efficacy of these methods in improving
# state preparation [#StatePrep]_ techniques by reducing the number of required gates, which we recommend you explore.
# As the availability of qubits increases, the relevance of these methods will grow making this operator an
# indispensable tool for developing new algorithms and an interesting field for further study.
#
# References
# ----------
#
# .. [#selectSwap]
#
#       Guang Hao Low, Vadym Kliuchnikov, and Luke Schaeffer,
#       "Trading T-gates for dirty qubits in state preparation and unitary synthesis",
#       `arXiv:1812.00954 <https://arxiv.org/abs/1812.00954>`__, 2018
#
# .. [#cleanQROM]
#
#       Dominic W. Berry, Craig Gidney, Mario Motta, Jarrod R. McClean, and Ryan Babbush,
#       "Qubitization of Arbitrary Basis Quantum Chemistry Leveraging Sparsity and Low Rank Factorization",
#       `Quantum 3, 208 <http://dx.doi.org/10.22331/q-2019-12-02-208>`__, 2019
#
# .. [#StatePrep]
#
#       Lov Grover and Terry Rudolph,
#       "Creating superpositions that correspond to efficiently integrable probability distributions",
#       `arXiv:quant-ph/0208112 <https://arxiv.org/abs/quant-ph/0208112>`__, 2002
#
# .. [#unary]
#
#       Guang Hao Low, Vadym Kliuchnikov, and Luke Schaeffer,
#       "Trading T-gates for dirty qubits in state preparation and unitary synthesis",
#       `arXiv:1812.00954 <https://arxiv.org/abs/1812.00954>`__, 2018
#
# About the author
# ----------------
