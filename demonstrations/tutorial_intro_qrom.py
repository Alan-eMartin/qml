r"""Intro to QROM
=============================================================

Storing and loading data is an indispensable task on any computer. Quantum computers are no different and getting this
done efficiently plays a crucial role in fields such as QML or can even be useful in search algorithms.
In this demo we will introduce the concept of QROM, the data structure that allows us to work towards this task.

QROM
-----

Quantum Read-Only Memory (QROM) is an operator that allows us to load classical data into a quantum computer
associated with indeces. This data is represented as a bitstring (list of 0s and 1s) and the operator can be defined as:

.. math::

    \text{QROM}|i\rangle|0\rangle = |i\rangle|b_i\rangle,

where :math:`|b_i\rangle` is the bitstring associated with the index :math:`i`.
Suppose our data consists of eight bit-strings :math:`[11, 01, 11, 00, 10, 10, 11, 00]`. Then, the index register will consist of three
qubits (:math:`\log_2 8`) and the target register of two qubits (length of the bit-strings). Following the same example,
:math:`\text{QROM}|010\rangle|00\rangle = |010\rangle|11\rangle`, since the bit-string associated with index :math:`2` is :math:`11`.
We will show three different implementations of this operator: Select, SelectSwap and an advanced version of the
last one.

Select
~~~~~~~

Select is an operator that prepares quantum states associated with indices. It is defined as:

.. math::

    \text{Sel}|i\rangle|0\rangle = |i\rangle|\phi_i\rangle,

where :math:`|\phi_i\rangle` is the i-th state we want to encode generated by a known-gate :math:`U_i`.
Since the bitstrings can be seen as a particular quantum state, we particularize this operator to the QROM case.
For the following example we are going to use :class:`~.pennylane.BasisEmbedding` as :math:`U_i`, and
the :class:`~.pennylane.Select` template provided by PennyLane.

"""

import pennylane as qml
from functools import partial

control_wires = [0,1,2]
target_wires = [3,4]

bitstrings = ["11", "01", "11", "00", "10", "10", "11", "00"]
Ui = [qml.BasisEmbedding(int(bitstring, 2), target_wires) for bitstring in bitstrings]

dev = qml.device("default.qubit", shots = 1)

# I put this line so that the circuit can be visualized more clearly afterwards.
@partial(qml.devices.preprocess.decompose,
         stopping_condition = lambda obj: False,
         max_expansion=1)
@qml.qnode(dev)
def circuit(index):
    qml.BasisEmbedding(index, wires=control_wires)
    qml.Select(Ui, control=control_wires)
    return qml.sample(wires=target_wires)

##############################################################################
# Once we have defined the circuit, we can draw it and check that the outputs are as expected.

import matplotlib.pyplot as plt

qml.draw_mpl(circuit)(0)
plt.show()

for i in range(8):
    print(f"The bitstring stored in the {i}-index is: {circuit(i)}")


##############################################################################
# Nice, you can see that the outputs match the elements of our initial data list.
#
# Although the algorithm works correctly, we can see that the number of multicontrol gates is high.
# The decomposition of these gates is expensive and there are numerous works that attempt to simplify this.
# We can highlight the work [google] which introduces an efficient technique making use of measurements in the middle
# of the circuit. Another clever approach was introduced in [here], with a smart structure known as SelectSwap.
#
# SelectSwap
# ~~~~~~~~~~
# The SelectSwap goal is to trade depth for width of the circuit. That is, using auxiliary qubits,
# reduce the number of gates required to build the QROM. We can detail the algorithm in two steps.
#
# First, We use the auxiliary qubits (work_wires) to store more than one bitstring in parallel.
# In this way, we reduce the workload of the Select block.
# Following the previous example, the new circuit will look like this:
#
# .. figure:: ../_static/demonstration_assets/qrom/select_block.jpeg
#    :align: center
#    :width: 70%
#    :target: javascript:void(0)

#    Example of Select block, where we use two auxiliary qubits to store two bitstrings in parallel.
#    With six work wires, we could store the bitstrings in groups of 4.
#
# The first two control qubits determine in which column the bitstring to load is located.
# But it still remains to move the correct row to the target position. To do this, we include a second block of SWAP gates
# controlled by the rest of the control qubits. This way, we can move the desired bitstring to the target position.
#
# .. figure:: ../_static/demonstration_assets/qrom/select_block.jpeg
#    :align: center
#    :width: 70%
#    :target: javascript:void(0)
#
# Note that with this circuit, for any index added in the control wires, the corresponding bitstring will be loaded
# into the target wires.
#
# Reusable SelectSwap
# ~~~~~~~~~~~~~~~~~~~
#
# Conclusion
# ----------
#
#
# About the author
# ----------------
# .. include:: ../_static/authors/juan_miguel_arrazola.txt
