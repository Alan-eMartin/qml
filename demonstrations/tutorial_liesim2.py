r"""(g + P)-sim: Extending g-sim by non-DLA observables and gates
=================================================================

In a :doc:`previous demo </demos/tutorial_liesim/` we introduced :math:`\mathfrak{g}`-sim, a Lie-algebraic simulation technique
of observables and gates comprised of Lie algebra elements. We extend :math:`\mathfrak{g}`-sim by
non-DLA elements comprised of products of DLA elements that are not in the DLA itself.

.. note::
    
    The contents of this demo are self-contained. However, we highly recommend reading our previous demos on
    :doc:`(dynamical) Lie algebras </demos/tutorial_liealgebra/` and :doc:`g-sim in PennyLane </demos/tutorial_liesim/`.

Introduction
------------

Lie-algebraic simulation techniques can be handy in the niche cases where the
:doc:`dynamical Lie algebras (DLA) </demos/tutorial_liealgebra/` scales polynomially with
the number of qubits. That is for example the case for the transverse field Ising model and variants thereof in 1D [#Wiersema]_.

In [#Goh]_, the authors hint at the possibility of extending :math:`\mathfrak{g}`-sim by the possibility of computing expectation values
of products of DLA elements, that we call `moments` of the DLA.
In this demo, we extend this notion to gates generated by moments of the DLA and introduce a more efficient
representation of this extension.

The final algorithm lets us compute expectation values of moments as well as circuits comprised of gates that are generated by higher moments.
The required order of the moments under consideration is determined by the number of non-DLA gates and their order.

The final computation is analogous to :math:`\mathfrak{g}`-sim, just using the vector space of moments instead of the DLA.

:math:`\mathfrak{g}`-sim
------------------------

Let us briefly recap the core principles of :math:`\mathfrak{g}`-sim. Let us consider a Lie algebra :math:`\mathfrak{g} = \{h_1, .., h_d\}` that is closed
under commutation (see :func:`~pennylane.lie_closure`). We know that gates :math:`e^{-i \theta h_\alpha}` transform Lie algebra elements to Lie
algebra elements,

.. math:: e^{i \theta h_\mu} h_\alpha e^{-i \theta h_\mu} = \sum_\beta e^{-i \theta f^\mu_{\alpha \beta}} h_\beta.

This is the adjoint identity with the adjoint representation of the Lie algebra given by the :func:`~pennylane.structure_constants`,
:math:`\left(\text{ad}_{h_\mu}\right)_{\alpha \beta} = f^\mu_{\alpha \beta}`.

This lets us evolve any expectation value of DLA elements using the adjoint representation of the DLA.
For that, let us define the expectation value vector :math:`(\vec{e})_\alpha = \text{tr}[h_\alpha \rho]`.
Also, let us write :math:`\tilde{U} = e^{-i \theta \text{ad}_{h_\mu}}` corresponding to a unitary :math:`U = e^{-i \theta h_\mu}`.
Using the adjoint identity above and the cyclic property of the trace, we can write an evolved expectation value vector as

.. math:: \text{tr}\left[h_\alpha U \rho U^\dagger\right] = \sum_\beta \tilde{U}_{\alpha \beta} \text{tr}\left[h_\beta \rho \right].

Hence, the expectation value vector is simply transformed by matrix multiplication with :math:`\tilde{U}` and we have

.. math:: \vec{e}^1 = \tilde{U} \vec{e}^0

for some input expectation value vector :math:`\vec{e}^0`.

A circuit comprised of multiple unitaries :math:`U` then simply corresponds to evolving the ecpectation value vector according to the product of 
the corresponding :math:`\tilde{U}`.

Moments
-------

A Lie algebra :math:`\mathfrak{g}` is closed under commutation, but not necessarily under (matrix) multiplication. Hence, in general a product
:math:`h_{\alpha_1} h_{\alpha_2}` of elements in :math:`\mathfrak{g}` is not necessarily in :math:`\mathfrak{g}`.
Whenever :math:`h_{\alpha_1} h_{\alpha_2} \notin \mathfrak{g}`, we call it a first moment of :math:`\mathfrak{g}`.
We can collect all first order moments in a vector space :math:`\mathcal{M}^1`.
Second order moments can be computed by looking at :math:`h_{\alpha_1} h_{\alpha_2} h_{\alpha_3} \mathfrak{g} \cup \mathcal{M}^1`.
Alternatively and more simply, we can check :math:`h_{\alpha_1} \tilde{h}_{\alpha_2} \notin \mathfrak{g} \cup \mathcal{M}^1`
with :math:`\tilde{h}_{\alpha_2} \in \mathcal{M}^1`.

We can continue this process until eventually the maximum order is reached and no new operators are generated. We have then successfully constructed the 
associative algebra of :math:`\mathfrak{g}`.

Let us walk through this process exemplarily for the DLA of the transverse field Ising model,

.. math:: H_\text{Ising} = J \sum_{i=1}^{n-1} X_i X_j + h \sum_{i=1}^n Z_i.

This is one of the few systems that yield a polynomially sized DLA.
Let us construct its DLA via :func:`~pennylane.lie_closure`.

"""

import pennylane as qml
from pennylane import X, Y, Z, I
from pennylane.pauli import PauliSentence, PauliWord, PauliVSpace

# TFIM generators
n = 4
generators = [
    X(i) @ X(i+1) for i in range(n-1)
]
generators += [
    Z(i) for i in range(n)
]
generators = [op.pauli_rep for op in generators]

dla = qml.pauli.lie_closure(generators, pauli=True)
dim_g = len(dla)

##############################################################################
#
# We now set up a vector space starting from the DLA and keep adding linearly independent product operators.

def Moment_step(ops):
    MomentX = PauliVSpace(ops.copy())
    for i, op1 in enumerate(dla):
        for op2 in ops[i+1:]:
            prod = op1 @ op2
            pw = next(iter(prod.keys())) # ignore scalar coefficient

            MomentX.add(pw)
    
    return MomentX.basis
Moment0 = dla.copy()
Moment = [Moment0]
dim = [len(Moment0)]
for i in range(1, 5):
    Moment.append(Moment_step(Moment[-1]))
    dim.append(len(Moment[-1]))

dim, 4**n-1

##############################################################################
# We see the growing dimension of the intermediate moment spaces. Eventually they saturate when reaching the maximum moment,
# which here is :math:`3`.
#
# It is important to recall that the (intermediate) moments generally do not form a Lie algebra. This is because
# they are not closed under commutation, which can be seen by comparing the dimension with
# that of its Lie closure.

Moment1_closure = qml.lie_closure(Moment[1])
len(Moment1_closure), len(Moment[1])

##############################################################################
#
# (:math:`\mathfrak{g}`+P)-sim
# ----------------------------
#
# The goal of (:math:`\mathfrak{g}`+P)-sim is to incorporate product operators (moments) as gates (:math:`P` gates).
# The resulting algorithm is surprisingly simple and analogous to :math:`\mathfrak{g}`-sim with just
# the DLA :math:`\mathfrak{g}` exchanged for a suitably chosen moment vector space.
#
# Let us walk through the algorithm.
# First, we compute the initial expectation value vector :math:`\vec{e}` for not just the DLA
# but the degree of moments we are considering. For now, let us just use the first moments
# (which will permit us to run :math:`(\mathfrak{g} + P)`-sim with one :math:`P`-gate later).

import numpy as np
from scipy.linalg import expm

def comp_e_in(pick_moment):
    # compute initial expectation vector
    e_in = np.zeros(dim[pick_moment], dtype=float)

    for i, h_i in enumerate(Moment[pick_moment]):
        # initial state |0x0| = (I + Z)/2, note that trace function
        # below already normalizes by the dimension,
        # so we can ommit the explicit factor /2
        rho_in = qml.prod(*(I(i) + Z(i) for i in h_i.wires))
        rho_in = rho_in.pauli_rep

        e_in[i] = (h_i @ rho_in).trace()
    return e_in

pick_moment = 1 # order of moments (=number of P gates)
e_in = comp_e_in(pick_moment)

##############################################################################
#
# Now, :math:`(\mathfrak{g} + P)`-sim works in the same way as regular :math:`\mathfrak{g}`-sim,
# just extended to the appropriately chosen moment vector space.
#
# Let us define a callable that computes the final expectation value of the TFIM Hamiltonian H_\text{Ising}
# with :math:`J=h=0.5`. For comparison, we also define a ``qnode`` that computes the same expectation value
# using a state vector simulator.

def run_gP_sim(e_in, coeff, gates):
    # simulation
    e_t = e_in.copy()
    for i in range(len(gates)):
        e_t = expm(coeff[i] * gates[i]) @ e_t

    # final expectation value
    # H = 0.5 @ generators (TFIM Hamiltonian)
    weights = np.zeros(dim[pick_moment], dtype=complex)
    weights[:len(generators)] = 0.5 

    return weights @ e_t

H = 0.5 * qml.sum(*[op.operation() for op in generators])

@qml.qnode(qml.device("default.qubit"))
def qnode(coeff, gates):
    for i in range(len(gates)):
        qml.exp(
            -1j * coeff[i] * gates[i]
        )
    return qml.expval(H)

##############################################################################
# We now set a random circuit by picking random generators from the DLA but allow for the central gate
# to be a :math:`P` gate from the first moments.

depth = 10
coeff = np.random.rand(depth)

adjoint_repr = qml.structure_constants(Moment[pick_moment])

for i in range(10):
    gate_choice = np.random.choice(dim_g, size=depth)
    gate_choice[depth//2] = np.random.choice(range(dim[0], dim[pick_moment]), size=(1,))[0] # one P gate
    gates = adjoint_repr[gate_choice]

    result_g_sim = run_gP_sim(e_in, coeff, gates)

    pl_gate_generators = [Moment[pick_moment][i].operation() for i in gate_choice]
    true_res = qnode(coeff, pl_gate_generators)

    if not np.allclose(result_g_sim, true_res):
        print(f"FAIL: g-sim res: {result_g_sim}, exact res: {true_res}")
    else:
        print(f"SUCCESS: g-sim res: {result_g_sim}, exact res: {true_res}")

##############################################################################
# If we want to succeed with two :math:`P^1` gates, we need to go up to the 2nd moments.

pick_moment = 2
adjoint_repr = qml.structure_constants(Moment[pick_moment])

for i in range(10):
    gate_choice = np.random.choice(dim_g, size=depth)
    gate_choice[depth//2] = np.random.choice(range(dim[0], dim[1]), size=(1,))[0] # 1st P^1 gate
    gate_choice[depth//2+1] = np.random.choice(range(dim[0], dim[1]), size=(1,))[0] # 2nd P^1 gate
    gates = adjoint_repr[gate_choice]

    result_g_sim = run_gP_sim(comp_e_in(pick_moment), coeff, gates)

    pl_gate_generators = [Moment[pick_moment][i].operation() for i in gate_choice]
    true_res = qnode(coeff, pl_gate_generators)

    if not np.allclose(result_g_sim, true_res):
        print(f"FAIL: g-sim res: {result_g_sim}, exact res: {true_res}")
    else:
        print(f"SUCCESS: g-sim res: {result_g_sim}, exact res: {true_res}")

##############################################################################
# We also need the 2nd moments if we want to succeed with one :math:`P^2` gate.

for i in range(10):
    gate_choice = np.random.choice(dim_g, size=depth)
    gate_choice[depth//2] = np.random.choice(range(dim[1], dim[2]), size=(1,))[0] # one P^2 gate
    gates = adjoint_repr[gate_choice]

    result_g_sim = run_gP_sim(comp_e_in(pick_moment), coeff, gates)

    pl_gate_generators = [Moment[pick_moment][i].operation() for i in gate_choice]
    true_res = qnode(coeff, pl_gate_generators)

    if not np.allclose(result_g_sim, true_res):
        print(f"FAIL: g-sim res: {result_g_sim}, exact res: {true_res}")
    else:
        print(f"SUCCESS: g-sim res: {result_g_sim}, exact res: {true_res}")

##############################################################################
#
# Computational bottlenecks
# ~~~~~~~~~~~~~~~~~~~~~~~~~
#
# As we go to larger moment spaces, the bottlebeck soon becomes computing :func:`~pennylane.structure_constants`.
# This function iterates over :math:`\tilde{d}^3/2` combinations, where :math:`\tilde{d}` is the dimension of the vector space
# of the moments we are considering. Instead of computing the adjoint representation for every element of the moment space
# we can also directly compute the adjoint action of every gate.
#
# We do that by simply projecting :math:`U^\dagger h_\alpha U \forall h_\alpha \in M^\mu(\mathfrak{g})` onto the basis of :math:`M^\mu(\mathfrak{g})`.
# Let us recall that even though the :math:`\mu`-th moment space :math:`M^\mu(\mathfrak{g})` generally does not form a Lie algebra, it is a valid 
# vector space by construction.
#
# We still need to iterate through :math:`\tilde{d}^2` elements, but can do that individually for only the :math:`D` gates in the circuit.
# So the cost here is :math:`D\tilde{d}^2`, which is worth while whenever 
# :math:`D \leq \tilde{d}/2`. Additionally, because we are dealing with Pauli words, we can avoid computing the exponential
# of the adjoint representation because there is an efficient formula
# :math:`e^{-i \theta \bigotimes_j P_j} = \cos(\theta) \mathbb{I} -i \sin(\theta) \bigotimes_j P_j` for the exponential of them.

def exppw(theta, ps):
    # assert that it is indeed a pure pauli word, not a sentence
    assert (len(ps) == 1 and isinstance(ps, PauliSentence)) or isinstance(ps, PauliWord)
    return np.cos(theta) * PauliWord({}) + 1j * np.sin(theta) * ps

pick_moment = 1 # setting back to 1 as we are only using 1 P^1 gate in this example

for i in range(10):
    gate_choice = np.random.choice(dim_g, size=depth)
    gate_choice[depth//2] = np.random.choice(range(dim[0], dim[pick_moment]), size=(1,))[0] # one P^1 gate
    gates = np.array(Moment[pick_moment])[gate_choice].tolist()
    # Compute adjoint actions of all gates
    adj_gates = []

    for i, t in enumerate(gates):
        theta = coeff[i]

        T = exppw(theta, t)
        Td = exppw(-theta, t) # complex conjugate

        # adjoint action of T, decomposed in elements of the vector space
        T_adj = np.zeros((dim[pick_moment], dim[pick_moment]), dtype=float)

        for i, h1 in enumerate(Moment[pick_moment]):
            res = T @ h1 @ Td
            for j, h2 in enumerate(Moment[pick_moment]):
                # decompose the result in terms of DLA elements
                # res = ∑ (res · h_j / ||h_j||^2) * h_j 
                value = (res @ h2).trace().real
                value = value / (h2 @ h2).trace()
                T_adj[i, j] = value

        adj_gates.append(T_adj)

    # simulation
    e_t = e_in.copy()
    for i in range(depth):
        e_t = adj_gates[i] @ e_t

    # H = 0.5 @ generators (not full dla)
    weights = np.zeros(dim[pick_moment], dtype=complex)
    weights[:len(generators)] = 0.5 

    result_g_sim = weights @ e_t

    pl_gate_generators = [Moment[pick_moment][i].operation() for i in gate_choice]
    true_res = qnode(coeff, pl_gate_generators)

    if not np.allclose(result_g_sim, true_res):
        print(f"FAIL: g-sim res: {result_g_sim}, exact res: {true_res}")
    else:
        print(f"SUCCESS: g-sim res: {result_g_sim}, exact res: {true_res}")


##############################################################################
# Alternatively, we can also speed up :func:`~pennylane.structure_constants` itself
# by making use of the fact that all computations in the outer loop are independent
# and use `embarrassing parallelism <https://en.wikipedia.org/wiki/Embarrassingly_parallel>`__.
#
# In python, this can be done with ``multiprocessing`` as follows.

import multiprocessing as mp
import concurrent.futures
from itertools import combinations

max_workers = 8 # number of CPU cores to distribute the task over

gtilde = Moment[pick_moment]
dtilde = len(gtilde)

# compute adjoint representation using embarrassing parallelism
chunk_size = dtilde // max_workers
chunks = [(i * chunk_size, (i + 1) * chunk_size) for i in range(max_workers)]
chunks[-1] = (chunks[-1][0], dtilde)

commutators = {}
for (j, op1), (k, op2) in combinations(enumerate(gtilde), r=2):
    res = op1.commutator(op2)
    if res != PauliSentence({}):
        commutators[(j, k)] = res

def _wrap_run_job(chunk):
    rep = np.zeros((np.diff(chunk)[0], len(gtilde), len(gtilde)), dtype=float)
    for idx, i in enumerate(range(*chunk)):
        op = gtilde[i]
        for (j, k), res in commutators.items():
            value = (1j * (op @ res).trace()).real
            value = value / (op @ op).trace()  # v = ∑ (v · e_j / ||e_j||^2) * e_j
            rep[idx, j, k] = value
            rep[idx, k, j] = -value
    return chunk, rep

with concurrent.futures.ProcessPoolExecutor(max_workers=max_workers, mp_context=mp.get_context('fork')) as executor:
    exec_map = executor.map(_wrap_run_job, chunks)
    results = tuple(circuit for circuit in exec_map)

rep = np.zeros((len(gtilde), len(gtilde), len(gtilde)), dtype=float)
for chunk, repi in results:
    rep[range(*chunk)] = repi

adjoint_repr2 = rep
np.allclose(adjoint_repr2, adjoint_repr)

##############################################################################
# 
# Conclusion
# ----------
#
# Great success
#



##############################################################################
# 
# References
# ----------
#
# .. [#Kottmann]
#
#     Korbinian Kottmann
#     "Introducing (Dynamical) Lie Algebras for quantum practitioners"
#     `PennyLane Demos <https://pennylane.ai/qml/demos/tutorial_liealgebra/>`__, 2024.
#
# .. [#Fontana]
#
#     Enrico Fontana, Dylan Herman, Shouvanik Chakrabarti, Niraj Kumar, Romina Yalovetzky, Jamie Heredge, Shree Hari Sureshbabu, Marco Pistoia
#     "The Adjoint Is All You Need: Characterizing Barren Plateaus in Quantum Ansätze"
#     `arXiv:2309.07902 <https://arxiv.org/abs/2309.07902>`__, 2023.
#
# .. [#Ragone]
#
#     Michael Ragone, Bojko N. Bakalov, Frédéric Sauvage, Alexander F. Kemper, Carlos Ortiz Marrero, Martin Larocca, M. Cerezo
#     "A Unified Theory of Barren Plateaus for Deep Parametrized Quantum Circuits"
#     `arXiv:2309.09342 <https://arxiv.org/abs/2309.09342>`__, 2023.
#
# .. [#Somma]
#
#     Rolando D. Somma
#     "Quantum Computation, Complexity, and Many-Body Physics"
#     `arXiv:quant-ph/0512209 <https://arxiv.org/abs/quant-ph/0512209>`__, 2005.
#
# .. [#Somma2]
#
#     Rolando Somma, Howard Barnum, Gerardo Ortiz, Emanuel Knill
#     "Efficient solvability of Hamiltonians and limits on the power of some quantum computational models"
#     `arXiv:quant-ph/0601030 <https://arxiv.org/abs/quant-ph/0601030>`__, 2006.
#
# .. [#Galitski]
#
#     Victor Galitski
#     "Quantum-to-Classical Correspondence and Hubbard-Stratonovich Dynamical Systems, a Lie-Algebraic Approach"
#     `arXiv:1012.2873 <https://arxiv.org/abs/1012.2873>`__, 2010.
#
# .. [#Goh]
#
#     Matthew L. Goh, Martin Larocca, Lukasz Cincio, M. Cerezo, Frédéric Sauvage
#     "Lie-algebraic classical simulations for variational quantum computing"
#     `arXiv:2308.01432 <https://arxiv.org/abs/2308.01432>`__, 2023.
#
# .. [#Cerezo]
#
#     M. Cerezo, Martin Larocca, Diego García-Martín, N. L. Diaz, Paolo Braccia, Enrico Fontana, Manuel S. Rudolph, Pablo Bermejo, Aroosa Ijaz, Supanut Thanasilp, Eric R. Anschuetz, Zoë Holmes
#     "Does provable absence of barren plateaus imply classical simulability? Or, why we need to rethink variational quantum computing"
#     `arXiv:2312.09121 <https://arxiv.org/abs/2312.09121>`__, 2023.
#
# .. [#Wiersema]
#
#     Roeland Wiersema, Efekan Kökcü, Alexander F. Kemper, Bojko N. Bakalov
#     "Classification of dynamical Lie algebras for translation-invariant 2-local spin systems in one dimension"
#     `arXiv:2309.05690 <https://arxiv.org/abs/2309.05690>`__, 2023.
#
# .. [#Mazzola]
#
#     Guglielmo Mazzola
#     "Quantum computing for chemistry and physics applications from a Monte Carlo perspective"
#     `arXiv:2308.07964 <https://arxiv.org/abs/2308.07964>`__, 2023.
#
# .. [#Park]
#
#     Chae-Yeun Park, Minhyeok Kang, Joonsuk Huh
#     "Hardware-efficient ansatz without barren plateaus in any depth"
#     `arXiv:2403.04844 <https://arxiv.org/abs/2403.04844>`__, 2024.
#

##############################################################################
# About the author
# ----------------
#
